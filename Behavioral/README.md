# 行为型模式

这些设计模式特别关注**对象之间的通信**。
增加了执行通信的灵活性。

## 责任链模式

* 简介

为请求创建了一个接收者对象的链。
通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

* 优点：
    1. 降低耦合度。它将请求的发送者和接收者解耦。
    2. 简化了对象。使得对象不需要知道链的结构。
    3. 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。
    4. 增加新的请求处理类很方便。

* 缺点：
    1. 不能保证请求一定被接收。
    2. 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。
    3. 可能不容易观察运行时的特征，有碍于除错。

* 使用场景：
    1. 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。
    2. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
    3. 可动态指定一组对象处理请求。

* 示例

> 场景：请求接口数据, 缓存上未找到, 委托给数据库查询接口。

## 命令模式

* 简介

请求以命令的形式包裹在对象中，并传给调用对象。
调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。
调用者→接受者→命令。

* 优点：
    1. 降低耦合度。
    2. 新的命令可以很容易添加到系统中去。

* 缺点：
    1. 使用命令模式可能会导致某些系统有过多的具体命令类。

* 使用场景：
    1. GUI 中每一个按钮都是一条命令。
    2. 模拟 CMD。

* 示例

> 场景：发送消息的命令

## 迭代器模式

* 简介

用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

* 优点：
    1. 支持以不同的方式遍历一个聚合对象。
    2. 迭代器简化了聚合类。
    3. 在同一个聚合上可以有多个遍历。
    4. 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。

* 缺点：
    1. 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。

* 使用场景：
    1. 访问一个聚合对象的内容而无须暴露它的内部表示。
    2. 需要为聚合对象提供多种遍历方式。
    3. 为遍历不同的聚合结构提供一个统一的接口。

* 示例

> 场景：遍历书单信息.

## 中介者模式

* 简介

用来降低多个对象和类之间的通信复杂性。
这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。

* 优点：
    1. 降低了类的复杂度，将一对多转化成了一对一。
    2. 各个类之间的解耦。
    3. 符合迪米特原则。

* 缺点：
    1. 中介者会庞大，变得复杂难以维护。

* 使用场景：
    1. 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。
    2. 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。

* 示例

> 场景：打印用户信息.
